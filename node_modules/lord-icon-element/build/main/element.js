import { replacePalette, replaceParams } from "../helpers/lottie.js";
import { deepClone } from "../helpers/utils.js";
import { loadIcon, loadLottieAnimation, registerIcon, registerLoader, registerAnimation, connectInstance, disconnectInstance, getIcon, getAnimation, } from "./manager.js";
const ELEMENT_STYLE = `
    :host {
        display: inline-flex;
        width: 32px;
        height: 32px;
        align-items: center;
        justify-content: center;
        position: relative;
        vertical-align: middle;
        fill: currentcolor;
        stroke: none;
        overflow: hidden;
    }

    svg {
        pointer-events: none;
        display: block;
    }

    div {    
        width: 100%;
        height: 100%;
    }

    div.slot {
        position: absolute;
        left: 0;
        top: 0;
        z-index: 2;
    }
`;
const OBSERVED_ATTRIBUTES = [
    "palette",
    "src",
    "icon",
    "animation",
    "speed",
    "target",
    "params",
];
export class Element extends HTMLElement {
    constructor() {
        super();
        this.isReady = false;
        this.root = this.attachShadow({ mode: "open" });
    }
    /**
     * Register Lottie library.
     * @param loader Provide "loadAnimation" here from Lottie.
     */
    static registerLoader(loader) {
        registerLoader(loader);
    }
    /**
     * Register supported icon.
     * @param name
     * @param data
     */
    static registerIcon(name, data) {
        registerIcon(name, data);
    }
    /**
     * Register supported animation.
     * @param name
     * @param animationClass
     */
    static registerAnimation(name, animationClass) {
        registerAnimation(name, animationClass);
    }
    /**
     * Element connected.
     */
    connectedCallback() {
        connectInstance(this);
        if (!this.isReady) {
            this.init();
        }
    }
    /**
     * Element disconnected.
     */
    disconnectedCallback() {
        this.unregisterLottie();
        disconnectInstance(this);
    }
    attributeChangedCallback(name, oldValue, newValue) {
        this[name] = newValue;
        const method = this[`${name}Changed`];
        if (method) {
            method.call(this);
        }
    }
    init() {
        if (this.isReady) {
            return;
        }
        this.isReady = true;
        const style = document.createElement("style");
        style.innerHTML = ELEMENT_STYLE;
        this.root.appendChild(style);
        const slotContainer = document.createElement("div");
        slotContainer.innerHTML = "<slot></slot>";
        slotContainer.classList.add("slot");
        this.root.appendChild(slotContainer);
        const container = document.createElement("div");
        this.root.appendChild(container);
        this.registerLottie();
    }
    registerLottie() {
        let iconData = this.iconData;
        if (!iconData) {
            return;
        }
        if (this.palette || this.params) {
            iconData = deepClone(iconData);
        }
        if (this.palette) {
            iconData = replacePalette(iconData, this.palette);
        }
        if (this.params) {
            iconData = replaceParams(iconData, this.params);
        }
        this.lottie = loadLottieAnimation({
            container: this.container,
            renderer: "svg",
            loop: false,
            autoplay: false,
            preserveAspectRatio: "xMidYMid meet",
            progressiveLoad: true,
            hideOnTransparent: false,
            animationData: iconData,
        });
        // set speed
        this.lottie.setSpeed(this.animationSpeed);
        // dispatch animation-complete
        this.lottie.addEventListener("complete", () => {
            this.dispatchEvent(new CustomEvent("animation-complete"));
        });
        this.animationChanged();
    }
    unregisterLottie() {
        if (this.myConnectedAnimation) {
            this.myConnectedAnimation.disconnectedCallback();
            this.myConnectedAnimation = undefined;
        }
        if (this.lottie) {
            this.lottie.destroy();
            this.lottie = undefined;
            this.container.innerHTML = "";
        }
    }
    notify(name, from) {
        if (this[from] !== name) {
            return;
        }
        if (from === "icon" && !this.lottie) {
            this.registerLottie();
        }
        else if (from === "animation" && !this.myConnectedAnimation) {
            this.animationChanged();
        }
    }
    animationChanged() {
        if (this.myConnectedAnimation) {
            this.myConnectedAnimation.disconnectedCallback();
            this.myConnectedAnimation = undefined;
        }
        if (this.animation && this.lottie) {
            const AnimationClass = getAnimation(this.animation);
            if (AnimationClass) {
                // find target event listener
                const target = this.target ? this.closest(this.target) : null;
                this.myConnectedAnimation = new AnimationClass(this, target || this, this.lottie);
                this.myConnectedAnimation.connectedCallback();
            }
        }
    }
    paletteChanged() {
        if (!this.isReady) {
            return;
        }
        this.unregisterLottie();
        this.registerLottie();
    }
    paramsChanged() {
        if (!this.isReady) {
            return;
        }
        this.unregisterLottie();
        this.registerLottie();
    }
    speedChanged() {
        if (this.lottie) {
            this.lottie.setSpeed(this.animationSpeed);
        }
    }
    iconChanged() {
        if (!this.isReady) {
            return;
        }
        this.unregisterLottie();
        this.registerLottie();
    }
    async srcChanged() {
        if (this.src) {
            await loadIcon(this.src);
        }
        if (!this.isReady) {
            return;
        }
        this.unregisterLottie();
        this.registerLottie();
    }
    /**
     * Acces icon data for this element.
     */
    get iconData() {
        if (this.icon && typeof this.icon === "object") {
            return this.icon;
        }
        return getIcon(this.icon || this.src);
    }
    /**
     * Access current animation instance.
     */
    get connectedAnimation() {
        return this.myConnectedAnimation;
    }
    get container() {
        return this.root.lastElementChild;
    }
    get animationSpeed() {
        return this.speed ? parseFloat(this.speed) || 1 : 1;
    }
    static get observedAttributes() {
        return OBSERVED_ATTRIBUTES;
    }
}
//# sourceMappingURL=element.js.map